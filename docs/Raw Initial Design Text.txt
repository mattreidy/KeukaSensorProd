This is a complete, copy-and-build design for a small, inexpensive, resilient water temperature + level station based on Raspberry Pi 3A+. It keeps your prototype’s exact HTTP output at /, adds a webcam stream, and includes a password-protected admin area with remote update/restart/reboot. It also adds a first-boot iPhone-friendly Wi-Fi provisioning AP (keukasensor / KeukaLake) and a long-range 2.4 GHz path using a USB Wi-Fi adapter with an external antenna.

1) High-level overview
What it does

Measures water level (ultrasonic down-looking sensor, mounted 3–5 ft above water) and water temperature (DS18B20 probe on the lake bottom).

Serves plain text at http://<ip>/ with the exact shape waterTempF,medianDistanceInches (two decimals each).

Serves a webcam page at http://<ip>/webcam (MJPEG stream at /stream).

Provides http://<ip>/admin protected by Basic Auth (admin/password initially — change it) with Update / Restart Service / Reboot and Wi-Fi setup.

Why it’s robust

All services managed by systemd (auto-restart); Flask gets permission to bind to port 80 without root.

Wi-Fi watchdog auto-recovers connectivity.

Median filtering, timeouts, and error handling in sensors.

No custom PCBs; all commodity parts.

Footprint & mounting

IP66/68 polycarbonate enclosure with clear lid, mounted vertical with the lid facing down toward water. The ultrasonic transducer head passes through the lid and points straight down; the USB webcam looks through the clear window.

2) Consolidated Bill of Materials (BoM)
Estimated 2025 street prices; pick equivalent parts from your preferred vendors. The USB adapter + external antenna provide long-range 2.4 GHz; onboard Wi-Fi is used only for the provisioning AP.

#	Item	Example / Notes	Qty	Est. Unit	Subtotal
1	Raspberry Pi 3A+	Full-size USB, onboard Wi-Fi	1	$45	$45
2	microSD 32 GB (A1)	OS & app	1	$7	$7
3	5V 3A PSU + micro-USB cable	Outdoor-rated if possible	1	$10	$10
4	USB UVC webcam (720p)	MJPEG capable	1	$12	$12
5	JSN-SR04T-2.0/3.0 ultrasonic	Waterproof head + controller PCB	1	$9	$9
6	DS18B20 waterproof probe	3-wire, 1-Wire, 3–10 m	1	$8	$8
7	IP66/68 enclosure, clear lid (~7×5×2 in)	Hammond 1554 series or equiv.	1	$25	$25
8	PG7 cable gland	DS18B20 lead	1	$2	$2
9	PG9 cable gland	5V power lead	1	$3	$3
10	RP-SMA bulkhead (IP67)	Wi-Fi antenna feed-through	1	$5	$5
11	RG316 RP-SMA pigtail (20–30 cm)	USB adapter ↔ bulkhead	1	$5	$5
12	2.4 GHz omni antenna (5–9 dBi)	Outdoor-rated preferred	1	$10	$10
13	USB 2.4 GHz Wi-Fi adapter (RP-SMA)	Panda PAU06 / Alfa AWUS036NH	1	$22	$22
14	Mounting L-bracket + stainless clamps	Dock/post mounting	1	$10	$10
15	Standoffs/screws/spacers kit	For Pi & PCB	1	$5	$5
16	Proto strip + resistors + wire	1 kΩ / 2 kΩ divider, jumpers	1	$3	$3
17	Desiccant + silicone sealant	Moisture control & sealing	1	$4	$4
18	Zip ties + adhesive anchors	Strain relief & cable dressing	1	$3	$3

Typical build total: ≈ $188
Likely range (sourcing dependent): $155 – $199

Notes:

Many JSN-SR04T kits include the transducer nut/O-ring; if not, add ~$2.

If you already have a suitable PSU or webcam, your total may be lower.

2A) External Wi-Fi & 2.4 GHz range plan
Why: 2.4 GHz generally travels farther / penetrates better than 5 GHz. We prioritize 2.4 GHz on a USB adapter with external RP-SMA antenna. Onboard Wi-Fi is kept for the provisioning AP.

Mechanical

Drill a 6.5–7 mm hole near the enclosure’s top side for the RP-SMA bulkhead, O-ring outside, nut inside.

Keep the antenna vertical and unobstructed (ideally lake-side of a dock post).

Inside: USB adapter ↔ RG316 pigtail ↔ bulkhead; use a short USB extension if needed for strain relief.

Regulatory domain

bash
Copy
Edit
sudo raspi-config nonint do_wifi_country US
2B) Initial Wi-Fi setup via onboard AP (iPhone-friendly provisioning)
Goal: On first boot, the Pi’s onboard Wi-Fi (wlan0) brings up an access point:

SSID keukasensor

Password KeukaLake

Static IP 192.168.50.1

Browse from iPhone to http://192.168.50.1/admin → Wi-Fi Setup to scan with wlan1 (USB adapter + external antenna), select an SSID, and connect.

Packages

bash
Copy
Edit
sudo apt update
sudo apt install -y hostapd dnsmasq
sudo systemctl unmask hostapd && sudo systemctl enable hostapd
sudo systemctl enable dnsmasq
Static IP for AP (wlan0) — /etc/dhcpcd.conf (append)

conf
Copy
Edit
interface wlan0
    static ip_address=192.168.50.1/24
    nohook wpa_supplicant
Restart: sudo systemctl restart dhcpcd

DHCP/DNS — /etc/dnsmasq.d/keukasensor.conf

conf
Copy
Edit
interface=wlan0
bind-interfaces
server=1.1.1.1
domain-needed
bogus-priv
dhcp-range=192.168.50.10,192.168.50.100,255.255.255.0,12h
AP config — /etc/hostapd/hostapd.conf

conf
Copy
Edit
country_code=US
interface=wlan0
driver=nl80211
ssid=keukasensor
hw_mode=g
channel=1
wmm_enabled=0
auth_algs=1
wpa=2
wpa_passphrase=KeukaLake
wpa_key_mgmt=WPA-PSK
rsn_pairwise=CCMP
Point hostapd to this config — /etc/default/hostapd

bash
Copy
Edit
echo 'DAEMON_CONF="/etc/hostapd/hostapd.conf"' | sudo tee /etc/default/hostapd
Enable services

bash
Copy
Edit
sudo systemctl enable --now hostapd dnsmasq
Station (wlan1) initial file — /etc/wpa_supplicant/wpa_supplicant-wlan1.conf

conf
Copy
Edit
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
country=US
Enable that instance:

bash
Copy
Edit
sudo systemctl enable --now wpa_supplicant@wlan1.service
Sudoers for safe Wi-Fi control

bash
Copy
Edit
echo 'pi ALL=(ALL) NOPASSWD: /usr/bin/systemctl restart keuka-sensor.service, /usr/sbin/reboot, /sbin/iw, /sbin/wpa_cli' | sudo tee /etc/sudoers.d/keuka-sensor
sudo chmod 440 /etc/sudoers.d/keuka-sensor
Workflow: join keukasensor / KeukaLake from iPhone → http://192.168.50.1/admin → Wi-Fi Setup → Scan → Select SSID → Enter password → Connect. The device associates on wlan1 while keeping the onboard AP on wlan0 as a management fallback.

3) Mechanical layout & mounting
Mount enclosure vertical, clear lid facing down toward water.

USB webcam inside, lens close to the clear window; add a small black foam shroud to cut reflections. Route the 5V power through the PG9 gland; strain-relief inside.

Drill 18 mm hole in the lid for the JSN-SR04T transducer head; seat flush, face straight down; seal with O-ring/silicone.

Drill 12 mm (PG7) for DS18B20 cable, 15–18 mm (PG9) for power, and 6.5–7 mm for RP-SMA bulkhead.

Target the ultrasonic head 36–60 in (0.9–1.5 m) above typical water level.

4) Electrical wiring
Pinout (BCM numbering)

JSN-SR04T: TRIG → GPIO 23, ECHO → voltage divider → GPIO 24, VCC 5V, GND GND.

DS18B20: DATA → GPIO 4 (1-Wire), VCC 3.3V, GND GND, plus 4.7 kΩ pull-up from DATA → 3.3V.

USB webcam → Pi USB.

USB Wi-Fi adapter → Pi USB; inside, adapter’s RP-SMA → RG316 pigtail → RP-SMA bulkhead; antenna outside.

Ultrasonic ECHO divider (5V → 3.3V)

less
Copy
Edit
JSN ECHO ---[ 1 kΩ ]---+--- to Pi GPIO24
                        |
                       [ 2 kΩ ]
                        |
                       GND
5) Software & OS setup (one-time)
Flash OS

Flash Raspberry Pi OS Lite (64-bit) to microSD.

In Raspberry Pi Imager Advanced: set hostname, enable SSH, set Wi-Fi/locale (optional).

Enable 1-Wire — /boot/firmware/config.txt

ini
Copy
Edit
# Enable 1-Wire on GPIO4 for DS18B20
dtoverlay=w1-gpio,gpiopin=4
Reboot; confirm /sys/bus/w1/devices/28-*/w1_slave exists.

Install Python deps

bash
Copy
Edit
sudo apt update
sudo apt install -y python3-pip python3-venv git
sudo mkdir -p /opt/keuka-sensor
sudo chown -R $USER:$USER /opt/keuka-sensor
python3 -m venv /opt/keuka-sensor/venv
source /opt/keuka-sensor/venv/bin/activate
pip install --upgrade pip
pip install flask opencv-python w1thermsensor numpy
If OpenCV is heavy on your build, you can use opencv-python-headless and keep 640×480 or lower the resolution to 320×240 in the code.

Project structure

/opt/keuka-sensor/keuka_sensor.py ← (full file below)

/opt/keuka-sensor/update.sh ← (below)

/etc/systemd/system/keuka-sensor.service ← (below)

/opt/keuka-sensor/wifi-watchdog.sh + /etc/systemd/system/wifi-watchdog.service ← (below)

6) Full application code (v1.3.0) — /opt/keuka-sensor/keuka_sensor.py
python
Copy
Edit
#!/usr/bin/env python3
import os
import sys
import time
import json
import threading
import subprocess
from datetime import datetime
from pathlib import Path
from flask import Flask, Response, request, abort, redirect, url_for, make_response

# Camera: OpenCV (optional)
try:
    import cv2  # type: ignore
except Exception:
    cv2 = None

# GPIO (allow import on dev machines)
try:
    import RPi.GPIO as GPIO  # type: ignore
except Exception:
    class _DummyGPIO:
        BCM = BOARD = IN = OUT = LOW = HIGH = PUD_DOWN = PUD_UP = None
        def setmode(self, *a, **k): pass
        def setwarnings(self, *a, **k): pass
        def setup(self, *a, **k): pass
        def output(self, *a, **k): pass
        def input(self, *a, **k): return 0
        def cleanup(self): pass
    GPIO = _DummyGPIO()

try:
    from w1thermsensor import W1ThermSensor  # type: ignore
except Exception:
    W1ThermSensor = None

# ---------------- Config ----------------
TRIG_PIN = 23
ECHO_PIN = 24
ULTRASONIC_TIMEOUT_S = 0.03
SAMPLES = 7
CAMERA_INDEX = 0
FRAME_W, FRAME_H = 640, 480
MJPEG_JPEG_QUALITY = 70

ADMIN_USER = os.environ.get("KS_ADMIN_USER", "admin")
ADMIN_PASS = os.environ.get("KS_ADMIN_PASS", "password")

APP_DIR = Path(__file__).resolve().parent
WLAN_STA_IFACE = os.environ.get("KS_STA_IFACE", "wlan1")  # USB adapter (external antenna)
WLAN_AP_IFACE  = os.environ.get("KS_AP_IFACE",  "wlan0")  # onboard AP
WPA_SUP_CONF = Path("/etc/wpa_supplicant/wpa_supplicant-" + WLAN_STA_IFACE + ".conf")

# ---------------- Flask -----------------
app = Flask(__name__)

# ---------------- Utils -----------------
def now() -> str:
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def basic_auth_ok(req) -> bool:
    a = req.authorization
    return bool(a and a.username == ADMIN_USER and a.password == ADMIN_PASS)

def sh(cmd):
    try:
        out = subprocess.check_output(cmd, stderr=subprocess.STDOUT, text=True)
        return 0, out
    except subprocess.CalledProcessError as e:
        return e.returncode, e.output

# ---- Camera worker ----
class Camera:
    def __init__(self, index=0, w=640, h=480):
        self.index = index; self.w=w; self.h=h
        self.cap=None; self.lock=threading.Lock(); self.frame=None; self.running=False
        self.thread = threading.Thread(target=self._worker, daemon=True)
    def start(self):
        if cv2 is None: return
        self.cap = cv2.VideoCapture(self.index)
        if not self.cap or not self.cap.isOpened(): return
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, self.w)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, self.h)
        self.running=True; self.thread.start()
    def _worker(self):
        while self.running and self.cap and self.cap.isOpened():
            ok, frm = self.cap.read()
            if ok:
                ok2, jpg = cv2.imencode('.jpg', frm, [int(cv2.IMWRITE_JPEG_QUALITY), MJPEG_JPEG_QUALITY])
                if ok2:
                    with self.lock:
                        self.frame = jpg.tobytes()
            else:
                time.sleep(0.05)
        if self.cap: self.cap.release()
    def get_jpeg(self):
        with self.lock: return self.frame
    def stop(self): self.running=False

camera = Camera(CAMERA_INDEX, FRAME_W, FRAME_H)

# ---- Ultrasonic (JSN-SR04T) ----
def _ultra_setup():
    GPIO.setwarnings(False)
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(TRIG_PIN, GPIO.OUT)
    GPIO.setup(ECHO_PIN, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
    GPIO.output(TRIG_PIN, GPIO.LOW)
    time.sleep(0.1)

_ultra_ready = False

def _ensure_ultra():
    global _ultra_ready
    if not _ultra_ready:
        _ultra_setup(); _ultra_ready=True

def read_distance_inches(timeout_s: float = ULTRASONIC_TIMEOUT_S) -> float:
    _ensure_ultra()
    GPIO.output(TRIG_PIN, GPIO.LOW); time.sleep(0.000002)
    GPIO.output(TRIG_PIN, GPIO.HIGH); time.sleep(0.000010)
    GPIO.output(TRIG_PIN, GPIO.LOW)
    start=time.time()
    while GPIO.input(ECHO_PIN)==0:
        if time.time()-start>timeout_s: return float('nan')
    t0=time.time()
    while GPIO.input(ECHO_PIN)==1:
        if time.time()-t0>timeout_s: return float('nan')
    t1=time.time(); dt=t1-t0
    return (dt*13503.9)/2.0

def median_distance_inches(samples=SAMPLES)->float:
    vals=[]
    for _ in range(samples):
        v=read_distance_inches()
        if not (v!=v or v==float('inf')): vals.append(v)
        time.sleep(0.075)
    if not vals: return float('nan')
    vals.sort(); return vals[len(vals)//2]

# ---- DS18B20 ----
def read_temp_fahrenheit()->float:
    try:
        if W1ThermSensor is not None:
            ss=W1ThermSensor.get_available_sensors()
            if ss:
                c=ss[0].get_temperature(); return c*9.0/5.0+32.0
    except Exception: pass
    base='/sys/bus/w1/devices'
    try:
        dev=next((d for d in os.listdir(base) if d.startswith('28-')))
        with open(os.path.join(base,dev,'w1_slave'),'r') as f: data=f.read()
        if 'YES' in data:
            c=float(data.strip().split('t=')[-1])/1000.0
            return c*9.0/5.0+32.0
    except Exception: pass
    return float('nan')

# ---- Wi-Fi helpers (wlan1 STA) ----
def wifi_status():
    code,out=sh(["iw","dev",WLAN_STA_IFACE,"link"])
    ssid=None; rssi=None; freq=None
    for ln in out.splitlines():
        ln=ln.strip()
        if ln.startswith('SSID:'): ssid=ln.split(':',1)[1].strip()
        elif ln.startswith('signal:'):
            try: rssi=int(ln.split()[1])
            except: pass
        elif ln.startswith('freq:'):
            try: freq=int(ln.split()[1])
            except: pass
    return {"iface":WLAN_STA_IFACE, "ssid":ssid, "signal_dbm":rssi, "freq_mhz":freq}

def wifi_scan()->list:
    code,out=sh(["sudo","/sbin/iw","dev",WLAN_STA_IFACE,"scan","-u"])
    nets=[]; cur={}
    for ln in out.splitlines():
        s=ln.strip()
        if s.startswith('BSS '):
            if cur.get('ssid'): nets.append(cur)
            cur={}
        elif s.startswith('SSID:'):
            cur['ssid']=s.split(':',1)[1].strip()
        elif s.startswith('signal:'):
            try: cur['signal_dbm']=int(s.split()[1])
            except: pass
        elif s.startswith('freq:'):
            try: cur['freq_mhz']=int(s.split()[1])
            except: pass
    if cur.get('ssid'): nets.append(cur)
    # dedupe SSIDs, keep best RSSI
    best={}
    for n in nets:
        k=n.get('ssid'); 
        if not k: continue
        if k not in best or (n.get('signal_dbm',-999) > best[k].get('signal_dbm',-999)):
            best[k]=n
    return sorted(best.values(), key=lambda x: x.get('signal_dbm',-999), reverse=True)

def wifi_connect(ssid:str, psk:str)->bool:
    WPA_SUP_CONF.parent.mkdir(parents=True, exist_ok=True)
    if not WPA_SUP_CONF.exists():
        WPA_SUP_CONF.write_text(
            "ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\n"
            "update_config=1\n"
            "country=US\n",
            encoding='utf-8'
        )
    conf = WPA_SUP_CONF.read_text(encoding='utf-8').splitlines()
    # Remove any existing block for this SSID (simple parser)
    out_lines=[]; in_block=False; keep_block=True; block=[]
    def flush_block():
        nonlocal out_lines, block, keep_block
        if keep_block: out_lines.extend(block)
    i=0
    while i < len(conf):
        ln = conf[i]
        if not in_block and ln.strip().startswith("network={"):
            in_block=True; block=[ln]; keep_block=True; i+=1; continue
        if in_block:
            block.append(ln)
            if 'ssid="' in ln:
                try:
                    existing = ln.split('ssid="',1)[1].split('"',1)[0]
                    if existing == ssid: keep_block=False
                except Exception:
                    pass
            if ln.strip()=="}":
                in_block=False; flush_block(); block=[]
            i+=1; continue
        out_lines.append(ln); i+=1
    # Append new block
    new_block = (
        "\nnetwork={\n"
        f'    ssid="{ssid}"\n'
        f'    psk="{psk}"\n'
        "    priority=10\n"
        "}\n"
    )
    out_text = "\n".join(out_lines) + new_block
    WPA_SUP_CONF.write_text(out_text, encoding='utf-8')
    sh(["sudo","/sbin/wpa_cli","-i",WLAN_STA_IFACE,"reconfigure"])
    return True

# ---------------- Routes ----------------
@app.route('/')
def root_plaintext():
    tF=read_temp_fahrenheit(); dIn=median_distance_inches()
    tF_out=0.0 if (tF!=tF) else tF
    dIn_out=0.0 if (dIn!=dIn) else dIn
    resp=make_response(f"{tF_out:.2f},{dIn_out:.2f}")
    resp.mimetype='text/plain'; return resp

@app.route('/webcam')
def webcam_page():
    html = (
        "<!doctype html><html><head><meta charset='utf-8'><title>Webcam</title></head>"
        "<body style='margin:0;background:#000;display:flex;align-items:center;justify-content:center;'>"
        "<img src='/stream' style='max-width:100%;height:auto;'>"
        "</body></html>"
    )
    return html

@app.route('/stream')
def stream_mjpeg():
    if cv2 is None: abort(503,'Webcam not available (OpenCV missing).')
    if not camera.running: camera.start()
    def gen():
        boundary = 'frame'
        while True:
            frm = camera.get_jpeg()
            if frm is None:
                time.sleep(0.05); continue
            yield (b"--" + boundary.encode() + b"\r\n"
                   b"Content-Type: image/jpeg\r\n\r\n" + frm + b"\r\n")
    return Response(gen(), mimetype='multipart/x-mixed-replace; boundary=frame')

@app.route('/health')
def health():
    tF=read_temp_fahrenheit(); dIn=median_distance_inches()
    st=wifi_status()
    return {
        "time": now(),
        "tempF": None if (tF!=tF) else round(tF,2),
        "distanceInches": None if (dIn!=dIn) else round(dIn,2),
        "camera": "running" if camera.running else "idle",
        "wifi": st,
        "app": "keuka-sensor",
        "version": "1.3.0"
    }

@app.route('/admin', methods=['GET'])
@app.route('/admin/<action>', methods=['POST'])
def admin(action=None):
    if not basic_auth_ok(request):
        return Response('Auth required',401,{"WWW-Authenticate":'Basic realm="KeukaSensor"'})
    if request.method=='POST':
        if action=='restart':
            subprocess.Popen(['sudo','systemctl','restart','keuka-sensor.service'])
            return redirect(url_for('admin'))
        if action=='reboot':
            subprocess.Popen(['sudo','reboot'])
            return 'Rebooting...',202
        if action=='update':
            script=str(APP_DIR/'update.sh')
            if os.path.exists(script):
                subprocess.Popen(['bash',script], cwd=str(APP_DIR))
                return redirect(url_for('admin'))
            return 'No update.sh found',404
    # info page
    ip=subprocess.getoutput("hostname -I | awk '{print $1}'")
    host=subprocess.getoutput('hostname')
    st=wifi_status()
    html = f"""
    <!doctype html><html><head><meta charset='utf-8'><title>Keuka Sensor Admin</title>
    <style>body{{font-family:system-ui,Segoe UI,Arial;margin:2rem}}button{{padding:.6rem 1rem;margin-right:.6rem}}.card{{border:1px solid #ddd;border-radius:10px;padding:1rem;margin:.5rem 0}}</style></head>
    <body>
      <h1>Keuka Sensor – Admin</h1>
      <div class='card'><b>Time:</b> {now()}<br><b>Host:</b> {host}<br><b>IP:</b> {ip}<br>
        <b>Wi-Fi (STA {WLAN_STA_IFACE}):</b> SSID {st.get('ssid') or '(n/a)'} | RSSI {st.get('signal_dbm') or '(n/a)'} dBm | Freq {st.get('freq_mhz') or '(n/a)'} MHz
      </div>
      <div class='card'>
        <form method='post' action='/admin/update' style='display:inline'><button>Update Code</button></form>
        <form method='post' action='/admin/restart' style='display:inline'><button>Restart Service</button></form>
        <form method='post' action='/admin/reboot' style='display:inline' onsubmit="return confirm('Reboot now?')"><button>Reboot Pi</button></form>
        <a href='/admin/wifi' style='margin-left:1rem'>Wi-Fi Setup</a>
      </div>
    </body></html>
    """
    return html

@app.route('/admin/wifi')
def admin_wifi():
    if not basic_auth_ok(request):
        return Response('Auth required',401,{"WWW-Authenticate":'Basic realm="KeukaSensor"'})
    html = f"""
    <!doctype html><html><head><meta charset='utf-8'><title>Wi-Fi Setup</title>
    <style>body{{font-family:system-ui,Segoe UI,Arial;margin:2rem}} table{{border-collapse:collapse}} td,th{{border:1px solid #ddd;padding:.4rem .6rem}}</style>
    <script>
      async function doScan(){{
        const r = await fetch('/admin/wifi/scan');
        const data = await r.json();
        const tb = document.getElementById('nets'); tb.innerHTML='';
        data.forEach(n=>{{
          const tr=document.createElement('tr');
          tr.innerHTML=`<td>${{n.ssid||'(hidden)'}} </td><td>${{n.signal_dbm||''}}</td><td>${{n.freq_mhz||''}}</td>
                         <td><button onclick=\\"sel('${{n.ssid||''}}')\\">Select</button></td>`;
          tb.appendChild(tr);
        }});
      }}
      function sel(ssid){{ document.getElementById('ssid').value = ssid; window.scrollTo(0,document.body.scrollHeight); }}
    </script>
    </head><body>
      <h1>Wi-Fi Setup (STA {WLAN_STA_IFACE})</h1>
      <button onclick='doScan()'>Scan Networks</button>
      <table style='margin-top:1rem'><thead><tr><th>SSID</th><th>RSSI (dBm)</th><th>Freq (MHz)</th><th></th></tr></thead><tbody id='nets'></tbody></table>
      <h2>Add/Connect</h2>
      <form method='post' action='/admin/wifi/connect'>
        <label>SSID <input id='ssid' name='ssid' required></label>
        <label style='margin-left:1rem'>Password <input name='psk' type='password' required></label>
        <button type='submit' style='margin-left:1rem'>Connect</button>
      </form>
      <p>Tip: If scan shows nothing (adapter missing), you can still enter SSID and password manually.</p>
    </body></html>
    """
    return html

@app.route('/admin/wifi/scan')
def wifi_scan_api():
    if not basic_auth_ok(request):
        return Response('Auth required',401,{"WWW-Authenticate":'Basic realm="KeukaSensor"'})
    return Response(json.dumps(wifi_scan()), mimetype='application/json')

@app.route('/admin/wifi/connect', methods=['POST'])
def wifi_connect_api():
    if not basic_auth_ok(request):
        return Response('Auth required',401,{"WWW-Authenticate":'Basic realm="KeukaSensor"'})
    ssid=request.form.get('ssid','').strip(); psk=request.form.get('psk','').strip()
    if not ssid or not psk: return 'Missing ssid/psk', 400
    wifi_connect(ssid, psk)
    time.sleep(1)
    return redirect(url_for('admin'))

if __name__=='__main__':
    app.run(host='0.0.0.0', port=80, debug=False, threaded=True)
7) Wi-Fi watchdog (v2) — /opt/keuka-sensor/wifi-watchdog.sh
bash
Copy
Edit
#!/usr/bin/env bash
set -euo pipefail

# Active interface and gateway from default route
IFACE=$(ip route | awk '/default/ {print $5; exit}')
GATEWAY=$(ip route | awk '/default/ {print $3; exit}')
[[ -z "${IFACE:-}" ]] && IFACE=$(iw dev | awk '/Interface/ {print $2; exit}')
[[ -z "${GATEWAY:-}" ]] && exit 0

# Ensure Wi-Fi not blocked
rfkill unblock wifi || true

# Test connectivity via the Wi-Fi interface
if ! ping -I "$IFACE" -c 2 -W 2 "$GATEWAY" >/dev/null 2>&1; then
  logger -t wifi-watchdog "Gateway unreachable via $IFACE, restarting Wi-Fi"
  wpa_cli -i "$IFACE" reconfigure >/dev/null 2>&1 || true
  ip link set "$IFACE" down || true
  sleep 1
  ip link set "$IFACE" up || true
  dhcpcd -n "$IFACE" >/dev/null 2>&1 || true
fi
Service unit — /etc/systemd/system/wifi-watchdog.service

ini
Copy
Edit
[Unit]
Description=Simple Wi-Fi Watchdog
After=network-online.target

[Service]
Type=simple
ExecStart=/bin/bash /opt/keuka-sensor/wifi-watchdog.sh
Restart=always
RestartSec=60

[Install]
WantedBy=multi-user.target
Enable:

bash
Copy
Edit
sudo systemctl daemon-reload
sudo systemctl enable --now wifi-watchdog.service
8) App service unit — /etc/systemd/system/keuka-sensor.service
Allows binding to port 80 as user pi via capabilities (no root needed).

ini
Copy
Edit
[Unit]
Description=Keuka Water Temp & Level Node
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=pi
WorkingDirectory=/opt/keuka-sensor
Environment=KS_ADMIN_USER=admin
Environment=KS_ADMIN_PASS=password
Environment=KS_STA_IFACE=wlan1
Environment=KS_AP_IFACE=wlan0
ExecStart=/opt/keuka-sensor/venv/bin/python /opt/keuka-sensor/keuka_sensor.py
Restart=always
RestartSec=3
# Allow binding to port 80 without root:
AmbientCapabilities=CAP_NET_BIND_SERVICE
CapabilityBoundingSet=CAP_NET_BIND_SERVICE
NoNewPrivileges=true

[Install]
WantedBy=multi-user.target
Enable & start:

bash
Copy
Edit
sudo systemctl daemon-reload
sudo systemctl enable --now keuka-sensor.service
9) Update script — /opt/keuka-sensor/update.sh
bash
Copy
Edit
#!/usr/bin/env bash
set -euo pipefail
cd "$(dirname "$0")"

# If this directory is a git repo, pull latest from origin/main
if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  echo "[update] Pulling latest from origin/main..."
  git fetch --all
  git reset --hard origin/main
else
  echo "[update] Not a git repo; place new files here manually or init a repo."
fi

# Restart service if running under systemd
if systemctl is-active --quiet keuka-sensor.service; then
  echo "[update] Restarting keuka-sensor.service"
  sudo systemctl restart keuka-sensor.service
fi

echo "[update] Done."
10) Testing checklist
curl http://<ip>/ → e.g., 77.79,31.11 (two decimals).

Browser → http://<ip>/webcam → live video.

curl http://<ip>/health → JSON with readings, wifi info.

http://<ip>/admin (Basic Auth) → try Update, Restart, Reboot.

AP provisioning: on iPhone join keukasensor / KeukaLake → http://192.168.50.1/admin → Wi-Fi Setup → Scan, Select, Connect.

11) Assembly steps (summary)
Prep enclosure: drill lid 18 mm (JSN head), side 12 mm (PG7), 15–18 mm (PG9 power), 6.5–7 mm (RP-SMA bulkhead). Deburr, clean.

Mount hardware: Pi on standoffs; JSN controller PCB on stand-off panel; feed DS18B20 through PG7; mount RP-SMA bulkhead.

Wire: build 1 kΩ / 2 kΩ divider for ECHO; wire TRIG/ECHO/VCC/GND; add 4.7 kΩ pull-up for DS18B20.

Camera: place webcam lens to clear lid; foam shroud to reduce glare; tilt slightly to avoid seeing ultrasonic head.

Seal: silicone around transducer & glands; add desiccant.

Software: flash OS, enable 1-Wire, install deps, copy files, enable services.

Mount: strap the enclosure to a post 3–5 ft above water; drop DS18B20 to bottom with small stainless weight.

Verify: run through the testing checklist.

12) Budget (roll-up)
Consolidated BoM total: ≈ $188 typical build

Range: $155 – $199 depending on Pi/enclosure/antenna sourcing

Optional add-ons not counted: ferrite on power lead ($3), conformal coat for JSN controller ($6–$10)

13) Maintenance & ops
Change admin creds: edit KS_ADMIN_USER / KS_ADMIN_PASS in the systemd unit → sudo systemctl daemon-reload && sudo systemctl restart keuka-sensor.

Code updates: use the Update Code button in /admin (runs update.sh → git hard-reset).

Logs: journalctl -u keuka-sensor -f.

For rough power, consider a high-endurance microSD.